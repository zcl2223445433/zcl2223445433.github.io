面向对象主要针对面向过程。

面向过程的基本单元是函数。

什么是对象：EVERYTHING IS OBJECT（万物皆对象）

所有的事物都有两个方面：

有什么（属性）：用来描述对象。

能够做什么（方法）：告诉外界对象有那些功能。

后者以前者为基础。

大的对象的属性也可以是一个对象。

为什么要使用面向对象：

首先，面向对象符合人类看待事物的一般规律。

对象的方法的实现细节是屏蔽的，只有对象方法的实现者了解细节。

方法的定义非常重要。方法有参数，也可能有返回值。

注意区分：对象（本身）、对象的实现者、对象的调用者。

分析对象主要从方法开始。

我们通过类来看待对象，类是对象的抽象。

其次，采用面向对象方法可以使系统各部分各司其职、各尽所能。

对象之间的耦合性一定要低（比如不同硬盘和不同主板之间的关系）。这样才能使每个对象本身做成最好的。

对于对象的要求：高内聚、低耦合，这样容易拼装成为一个系统。

实现高内聚就是要最大限度低提高复用性（复用性好是因为高内聚）。

可复用性是OOP的基础。

比较面向过程的思想和面向对象的思想：

面向过程的思想：由过程、步骤、函数组成，以过程为核心；
面向对象的思想：以对象为中心，先开发类，得到对象，通过对象之间相互通信实现功能。

面向过程是先有算法，后有数据结构。

面向对象是先有数据结构，然后再有算法。

在用面向对象思想开发的过程中，可以复用对象就进行复用，如无法进行复用则开发新的对象。

开发过程是用对个简单的对象的多个简单的方法，来实现复杂的功能 。

从语法上来看，一个类是一个新的数据类型。

在面向对象编程中，除了简单数据类型，就是对象类型。

定义类的格式：

class  Student{

    代码

}

注意类名中单词的首字母大写。

实例变量：定义在类中但在任何方法之外。（New出来的均有初值）

局部变量：定义在方法之中的变量。

局部变量要先赋值，再进行运算，而实例变量均已经赋初值。这是局部变量和实例变量的一大区别。

实例变量的对象赋值为null。

局部变量不允许范围内定义两个同名变量。实例变量的作用域在本类中完全有效，当被其他的类调用的时候也可能有效。

实例变量和局部变量允许命名冲突。

书写方法的格式：

    修饰符返回值    方法名     调用过程中               方法体

可能出现的例外

    publicint/voidaddNumber(参数)throw Excepion             {}


例：

    public  int  addNumber(int a,int b){

    }

注：方法名中的参数int a,int b为局部变量


类方法中的一类特殊方法：构造方法。

构造方法是当用类生成对象时，系统在生成对象的过程中利用的方法。

注意：构造方法在生成对象的时候会被调用，但并不是构造方法生成了对象。

构造方法没有返回值。格式为：public 方法名。

构造方法的方法名与类名相同。

构造方法是在对象生成的过程中自动调用，不可能利用指令去调用。

在一个对象的生成周期中构造方法只用一次，一旦这个对象生成，那么这个构造方法失效。


用类来生成对象的语句：

    Student s=new Student()。

第一个Student表示这是用Student类进行定义。“Student()”表示调用一个无参数的构造方法。

如果()中有参数，则系统构造对象的过程中调用有参的方法。

此时S称为一个对象变量。

 Student  s的存储区域存放的是地址：一个对象在硬盘上占有一个连续地址，首地址赋予s空间。

S称为对象Student的引用。

注意：在对象变量中存放的是引用（地址）；在简单变量中存放的是数值。


可以构造多个构造方法，但多个构造方法的参数表一定不同，参数顺序不同即属于不同的构造方法：

    public student(string name,int a){

    }

    public student(int a,string name){

    }

为两个不同的构造方法。

如果我们未给系统提供一个构造方法，那么系统会自动提供一个为空的构造方法。

练习：写一个类，定义一个对象，定义两个构造方法：一个有参，一个无参。

（编写一个程序验证对象的传递的值为地址）

注意下面这种形式：

    static void changename(student stu){stu.setName     “LUCY”}

注意生成新的对象与旧对象指向无关，生成新对象生命消亡与旧对象无关。


面向对象方法的重载（overloading）和覆盖（overriding）。

在有些JAVA书籍中将overriding称为重载，overloading称为过载。

Overloading在一个类中可以定义多个同名方法，各个方法的参数表一定不同。但修饰词可能相同，返回值也可能相同。

在程序的编译过程中根据变量类型来找相应的方法。因此也有人认为 overloading是编译时的多态，以后我们还会学到运行时多态。


为什么会存在overloading技术呢？作为应对方法的细节。

利用类型的差异来影响对方法的调用。

吃（）可以分为吃肉，吃菜，吃药，在一个类中可以定义多个吃方法。


构造方法也可以实现overloading。例：

public  void  teach(){};

public  void  teach(int a){};

public  void  teach(String a){}为三种不同的方法。

Overloading方法是从低向高转。

Byte—short—float—int—long—double。

在构造方法中，this表示本类的其他构造方法：

    student(){};

    student(string n){

    this();//表示调用student()

    }

如果调用student(int a)则为this(int a)。

特别注意：用this调用其他构造方法时，this必须为第一条语句，然后才是其他语句。

This表示当前对象。

    Public  void  printNum(){

         Int number=40；

    System.out.println(this.number); 

    }

此时打印的是实例变量，而非局部变量，即定义在类中而非方法中的变量。

This.number表示实例变量。

谁调用this.number那么谁即为当前(this)对象的number方法。

封装：使对象的属性尽可能私有，对象的方法尽可能的公开。用private表示此成员属性为该类的私有属性。

Public表示该属性（方法）公开；

Private表示该属性（方法）为只有本类内部可以访问（类内部可见）。

（想用private还要用set和get方法供其他方法调用，这样可以保证对属性的访问方式统一，并且便于维护访问权限以及属性数据合法性）

如果没有特殊情况，属性一定私有，方法该公开的公开。

如果不指明谁调用方法，则默认为this。

区分实例变量和局部变量时一定要写this。

11.29

继承：

父类（SuperClass）和 子类（SonClass）。

父类的非私有化属性和方法可以默认继承到子类。

Class Son extends Father{

}

而如果父类中的私有方法被子类调用的话，则编译报错。


父类的构造方法子类不可以继承，更不存在覆盖的问题。（非构造方法可以）

如果子类访问父类的构造方法，则在编译的时候提示访问不到该方法。

JAVA中不允许多继承，一个类有且只有一个父类（单继承）。

JAVA的数据结构为树型结构，而非网状。（JAVA通过接口和内部类实现多继承）

方法的覆盖（overriding）

方法的重载并不一定是在一个类中：子类可以从父类继承一个方法，也可以定义一个同名异参的方法，也称为overloading。

当子类从父类继承一个无参方法，而又定义了一个同样的无参方法，则子类新写的方法覆盖父类的方法，称为覆盖。（注意返回值类型也必须相同，否则编译出错。）

如果方法不同，则成重载。

对于方法的修饰词，子类方法要比父类的方法范围更加的宽泛。

父类为public，那么子类为private则出现错误。

之所以构造方法先运行父类再运行子类是因为构造方法是无法覆盖的。

以下范围依次由严到宽：

private ：本类访问；

default ：表示默认，不仅本类访问，而且是同包可见。

Protected：同包可见+不同包的子类可见

Public ：表示所有的地方均可见。

当构造一个对象的时候，系统先构造父类对象，再构造子类对象。

构造一个对象的顺序：（注意：构造父类对象的时候也是这几步）

① 递归地构造父类对象；

② 顺序地调用本类成员属性赋初值语句；

③ 本类的构造方法。

Super()表示调用父类的构造方法。

Super()也和this一样必须放在第一行。

This()用于调用本类的构造方法。

如果没有定义构造方法，那么就会调用父类的无参构造方法，即super()。


要养成良好的编程习惯：就是要加上默认的父类无参的构造方法。

思考：可是如果我们没有定义无参的构造方法，而在程序中构造了有参的构造方法，那么如果方法中没有参数，那么系统还会调用有参的构造方法么？应该不会。


多态：多态指的是编译时类型变化，而运行时类型不变。

多态分两种：

① 编译时多态：编译时动态重载；

② 运行时多态：指一个对象可以具有多个类型。


对象是客观的，人对对象的认识是主观的。

例：

Animal a=new Dog()；查看格式名称；

Dog d=(Dog)a。声明父类来引用子类。

（思考上面的格式）


运行时多态的三原则：（应用时为覆盖）

1、 对象不变；（改变的是主观认识）

2、 对于对象的调用只能限于编译时类型的方法，如调用运行时类型方法报错。

在上面的例子中：Animal a=new Dog()；对象a的编译时类型为Animal，运行时类型为dog。

注意：编译时类型一定要为运行时类型的父类（或者同类型）。

对于语句：Dog d=(Dog)a。将d强制声明为a类型，此时d为Dog()，此时d就可以调用运行时类型。注意：a和d指向同一对象。

3、 在程序的运行时，动态类型判定。运行时调用运行时类型，即它调用覆盖后的方法。

关系运算符：instanceof

a  instanceof Animal;(这个式子的结果是一个布尔表达式)

a为对象变量，Animal是类名。

上面语句是判定a是否可以贴Animal标签。如果可以贴则返回true，否则返回false。

在上面的题目中： a instanceofAnimal返回 True，

a instanceofDog也返回 True，

instanceof用于判定是否将前面的对象变量赋值后边的类名。

Instanceof一般用于在强制类型转换之前判定变量是否可以强制转换。

如果Animal a=new Animal()；

Dog d=Dog()a;

此时编译无误，但运行则会报错。

Animal a=new Dog()相当于下面语句的功能：

Animal a=getAnimal()；

Public static Animal.getAnimal;

Return new Dog()；

封装、继承、多态为面向对象的三大基石（特性）。

运行时的动态类型判定针对的是方法。运行程序访问的属性仍为编译时属性。

Overloading针对的是编译时类型，不存在运行时的多态。

覆盖时考虑子类的private及父类的public（考虑多态），之所以这样是避免调用A时出现实际调用B的情况。而出现错误。

面向对象高级、集合和例外都是面向对象的核心内容。


面向对象高级：   修饰符：

static:①可修饰变量（属性）；②可修饰方法；③可修饰代码块。

Staticint data语句说明data为类变量，为一个类的共享变量，属于整个类。

Int data为实例变量。

例：

    static int data;

    m1.data=0;

    m1.data++的结果为1,此时m2.data的结果也为1。

Static定义的是一块为整个类共有的一块存储区域，其发生变化时访问到的数据都时经过变化的。

其变量可以通过类名去访问：类名.变量名。与通过访问对象的编译时类型访问类变量为等价的。

Public static void printData(){}

表明此类方法为类方法（静态方法）

静态方法不需要有对象，可以使用类名调用。

静态方法中不允许访问类的非静态成员，包括成员的变量和方法，因为此时是通过类调用的，没有对象的概念。This.data是不可用的。

一般情况下，主方法是静态方法，所以可调用静态方法，主方法为静态方法是因为它是整个软件系统的入口，而进入入口时系统中没有任何对象，只能使用类调用。

覆盖不适用于静态方法。

静态方法不可被覆盖。（允许在子类中定义同名静态方法，但是没有多态，严格的讲，方法间没有多态就不能称为覆盖）

当static修饰代码块时（注：此代码块要在此类的任何一个方法之外），那么这个代码块在代码被装载进虚拟机生成对象的时候可被装载一次，以后再也不执行了。

一般静态代码块被用来初始化静态成员。

Static通常用于Singleton模式开发：

Singleton是一种设计模式，高于语法，可以保证一个类在整个系统中仅有一个对象。

final可以修饰类、属性、方法。

当用final修饰类的时候，此类不可被继承，即final类没有子类。这样可以用final保证用户调用时动作的一致性，可以防止子类覆盖情况的发生。

当利用final修饰一个属性（变量）的时候，此时的属性成为常量。

JAVA利用final定义常量（注意在JAVA命名规范中常量需要全部字母都大写）：

Final int AGE=10；

常量的地址不可改变，但在地址中保存的值（即对象的属性）是可以改变的。


Final可以配合static使用。  

Static final int age=10；

在JAVA中利用public static final的组合方式对常量进行标识（固定格式）。

对于在构造方法中利用final进行赋值的时候，此时在构造之前系统设置的默认值相对于构造方法失效。

常量（这里的常量指的是实例常量：即成员变量）赋值：

①在初始化的时候通过显式声明赋值。Final int x=3；

②在构造的时候赋值。

局部变量可以随时赋值。

利用final定义方法：这样的方法为一个不可覆盖的方法。

Public final void print(){}；

为了保证方法的一致性（即不被改变），可将方法用final定义。

如果在父类中有final定义的方法，那么在子类中继承同一个方法。

如果一个方法前有修饰词private或static，则系统会自动在前面加上final。即private和static方法默认均为final方法。

注：final并不涉及继承，继承取决于类的修饰符是否为private、default、protected还是public。也就是说，是否继承取决于这个方法对于子类是否可见。

Abstract(抽象)可以修饰类、方法

如果将一个类设置为abstract，则此类必须被继承使用。此类不可生成对象，必须被继承使用。

Abstract可以将子类的共性最大限度的抽取出来，放在父类中，以提高程序的简洁性。

Abstract虽然不能生成对象，但是可以声明，作为编译时类型，但不能作为运行时类型。

Final和abstract永远不会同时出现。

当abstract用于修饰方法时，此时该方法为抽象方法，此时方法不需要实现，实现留给子类覆盖，子类覆盖该方法之后方法才能够生效。

注意比较：

privatevoid print(){}；此语句表示方法的空实现。

Abstract void print()； 此语句表示方法的抽象，无实现。

如果一个类中有一个抽象方法，那么这个类一定为一个抽象类。

反之，如果一个类为抽象类，那么其中可能有非抽象的方法。

如果让一个非抽象类继承一个含抽象方法的抽象类，则编译时会发生错误。因为当一个非抽象类继承一个抽象方法的时候，本着只有一个类中有一个抽象方法，那么这个类必须为抽象类的原则。这个类必须为抽象类，这与此类为非抽象冲突，所以报错。


所以子类的方法必须覆盖父类的抽象方法。方法才能够起作用。

只有将理论被熟练运用在实际的程序设计的过程中之后，才能说理论被完全掌握！

为了实现多态，那么父类必须有定义。而父类并不实现，留给子类去实现。此时可将父类定义成abstract类。如果没有定义抽象的父类，那么编译会出现错误。


Abstract和static不能放在一起，否则便会出现错误。（这是因为static不可被覆盖，而abstract为了生效必须被覆盖。）
例：
    public class TestClass{

    public static void main(String[] args){

    SuperClass sc=new SubClass();

    Sc.print();

    }

Abstract class SuperClass{

Abstract void print();}

}

    class SubClass extends SuperClass(){

     void print(){

    System.out.println(“print”);}

    }